---
path: react-pdf-w-user-generated-content
date: 2020-03-02T18:21:31.257Z
title: Elegant PDFs from User Generated Content in React
description: >-
  Learn how to use DraftJS, Redraft, and React PDF to generate elegant PDFs with
  user generated content.
---
Converting user generate HTML into a PDF has always been a pain. Youâ€™re stuck with solutions like [wkhtmltopdf](https://wkhtmltopdf.org/), [PhantomJS](https://coderwall.com/p/5vmo1g/use-phantomjs-to-create-pdfs-from-html), or [Headless Chrome](https://developers.google.com/web/updates/2017/04/headless-chrome#create_a_pdf_dom). The problem I have found with all of these tools is that they are either slow, fail to match styles, or require running on a server. At CompayCam we allow our users to generate reports, some of which are hundreds of pages long. No matter how you slice it, that makes any of the options above much more difficult, especially if you allow the user to preview their PDF.

In this post we will look at how we use a combination of React PDF, DraftJS, and Redraft to craft a PDF from user generated content that is instantly available in the users browser for preview and download.

We allow users to build reports using photos they captured in CompanyCam. They can add comments using a WYSIWYG editor and choose if they want to show any metadata such as the capture time, who took the photo the project the photo belongs to.

## The Flow
When the user selects to generate a PDF of the report they are viewing we open a modal and finish fetching all of the pages of entries if necessary. Once we have all of the data we can get down to work. We pass the report to our `PDF` component, which is responsible for bootstrapping some libraries, generating a PDF and converting it to a blob, and then rendering the preview.

We start by importing the `pdf` function from `@react-pdf/renderer` and passing our `Document` component. The `Document` component will be shown later, for now just know that it generates and returns components using @react-pdf, DraftJS, and Redraft.

```
import { pdf } from â€˜@react-pdf/rendererâ€™;

Const PDF = ({ report }) => {
  const [loading, setLoading] = useState(true);
  const [documentURL, setDocumentURL] = useState();
  Const [numPages, setNumPages] = useState(0);

  useEffect(
    () => {
      const generateBlob = async () => {
        setLoading(true);
        const blob = await pdf(
          <Document report={report} imageSize={imageSize} />,
        ).toBlob();
        setLoading(false);
        setDocumentURL(window.URL.createObjectURL(blob));
      };

      if (report) {
        generateBlob();
      } else {
        setLoading(false);
        setDocumentURL(null);
      }
    },
    [report],
  );
};
```

We await the `pdf` function and then call `toBlob` which returns `Blob` object. We generate a URL for the blob using `URL.createObjectURL`  and then store that in the state. We can use the URL of the blob with the similarly and confusingly named `react-pdf`.

```
import { pdfjs, Document as PDFDocument, Page as PDFPage } from â€˜react-pdfâ€™;

pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.js`;

const PDF = ({ report }) => {
  // PDF generation omitted here.

	if (loading) {
    return <Spinner message="Fetching Images" />;
  }

  return (
    <React.Fragment>
      {loading && <div>Rendering PDFâ€¦</div>}
      <div>
        <a
          href={documentURL}
          className="ccb-blue-small"
          style={{ margin: â€˜auto 0 0â€™ }}
          download={filename}
        >
          Download PDF
        </a>
      </div>
      <PDFDocument
        file={documentURL}
        onLoadSuccess={(result) => setNumPages(result.numPages)}
        loading={<Spinner />}
      >
        <PDFPage
          renderMode="svg"
          pageNumber={currentPage}
        />
      </PDFDocument>
    </React.Fragment>
	);
}
```

Once we have the documentURL generated by `@react-pdf` we can render the preview using `react-pdf` (try and keep those two straight ðŸ™‚). We pass the `PDFDocument` component the `documentURL` as the file. Once the document is loaded it will call `onLoadSuccess` and tell us some info such as how many pages the preview is. Inside of that, we pass a `PDFPage` component and tell it to either render using a `canvas` or `svg` and which page we want to display.

You will notice that we can pass the `documentURL` as the `href` and a filename to the `download` prop for the `a` tag and it will download the blob with the filename specified.

I omitted the code that shows how we change the page for brevity. The code is a simple click handler that increments or decrements the `currentPage` state making sure you stay in bounds.

Cool, so now we know how to render and display the document returned from `Document`, but what does `Document` do and how do we convert HTML to `@react-pdf` components?

## Document Rendering and Content Conversion
React-PDF handles almost everything for you out of the box so the `Document` component is fairly simple:
```
import {
  Document as PDFDocument,
  StyleSheet,
  Page,
  Font,
} from â€˜@react-pdf/rendererâ€™;
import PageFooter from â€˜./PageFooterâ€™;
import CoverPage from â€˜./CoverPageâ€™;
import Entry from â€˜./Entryâ€™;

Font.register({
  family: â€˜Public Sansâ€™,
  fonts: [
    { src: â€˜https://cdn.companycam.com/fonts/PublicSans-Regular.ttfâ€™ },
    {
      src: â€˜https://cdn.companycam.com/fonts/PublicSans-SemiBold.ttfâ€™,
      fontWeight: 700,
    },
  ],
});

// Allow users to use emojis in markup
Font.registerEmojiSource({
  format: â€˜pngâ€™,
  url: â€˜https://twemoji.maxcdn.com/2/72x72/â€˜,
});

const styles = StyleSheet.create({
  // omitted for brevity
});

const Document = ({ report }) => {
  const { 
	  entries, 
	  settings, 
	  photoCount,
    company,
    title,
    subtitle,
    createdAt,
    featuredEntry
  } = report;

  const { name, logoLargeUrl } = company;
  const featuredPhoto = featuredEntry.assetPreviewLarge;

  return (
    <PDFDocument>
      <Page style={pageStyles} size="LETTER">
        <PageFooter title={title} />
        <CoverPage
          companyName={name}
          logo={logoLargeUrl}
          title={title}
          subtitle={subtitle}
          createdAt={createdAt}
          featuredPhoto={featuredPhoto}
          photoCount={photoCount}
        />
      </Page>
      <Page style={pageStyles} size="LETTER">
        <PageFooter title={title} />
        {entries.map((entry) => {
          return (
            <Entry
              key={entry.id}
              entry={entry}
              settings={settings}
            />
          );
        })}
      </Page>
    </PDFDocument>
  );
};

export default Document;
```

The wrapping component is the `Document` component imported from `@react-pdf`, this is important because it can be rendered by the `pdf` function in our `PDF` component. The `Page`, `CoverPage` and `PageFooter` are all self explanatory so I wonâ€™t show the code. It renders a page at the beginning of the document with the companies name and title of the report. We then render an `Entry` for each item in the report. The interesting part here is that we wrap all entries in a single `Page` component. React PDF has a pretty advanced wrapping engine and also allows passing a `break` prop to add a page break before the component it is rendering.

I am also going to omit the `Entry` component as well. It returns a `View` component that represents an item in the report. The only interesting part is that it renders a `RichText` component, and this is where the magic happens.

## Redraft Meet React PDF
So far most of the code I have shown you isnâ€™t anything earth shattering. I included it so you could have a better understanding of the hierarchy and flow of the code. In the `RichText` component we actually do some more interesting work.

```
import {
  EditorState,
  ContentState,
  convertToRaw,
  convertFromHTML,
} from â€˜draft-jsâ€™;
import redraft from â€˜redraftâ€™;

const RichText = ({ note }) => {
  const blocksFromHTML = convertFromHTML(note);
  const initialState = ContentState.createFromBlockArray(
    blocksFromHTML.contentBlocks,
    blocksFromHTML.entityMap,
  );

  const editorState = EditorState.createWithContent(initialState);
  const rawContent = convertToRaw(editorState.getCurrentContent());

  return redraft(rawContent, renderers, { blockFallback: â€˜unstyledâ€™ });
};

export default RichText;
```

The component is quite simple, it handles converting the HTML to a format that is understood by DraftJS using `convertFromHTML`. 
> If youâ€™re using DraftJS to generate the HTML, you can store the raw JS object from Draft using `convertToRaw` while editing.

Once we have converted the HTML into _blocks_, we initialize a `ContentState` and an `EditorState`. We do all of that to finally get the `rawContent`. The raw content is a regular oleâ€™ JS object and is understandable if you log it to the console. Finally weâ€™re at the cool part, we return the result of calling `redraft` with the `rawContent`, `renderers`, and some options.

## Renderers
The renderers iterate over the blocks, inline elements, and entities in the raw JS object and call the corresponding function based on the type. Draft [supports a handful of elements out of the box](https://draftjs.org/docs/advanced-topics-custom-block-render-map), so we just have to make a compatible React PDF component for each of the types we want to support. Letâ€™s take a look at our `renderers`:
```
import { StyleSheet, View, Text, Link } from â€˜@react-pdf/rendererâ€™;


const renderers = {
  inline: {
    // The key passed here is just an index based on rendering order inside a block
    BOLD: (children, { key }) => {
      return (
        <Text key={`bold-${key}`} style={{ fontWeight: 700 }}>
          {children}
        </Text>
      );
    },
    ITALIC: (children, { key }) => {
      return (
        <Text key={`italic-${key}`} style={{ fontStyle: â€˜italicâ€™ }}>
          {children}
        </Text>
      );
    },
    UNDERLINE: (children, { key }) => {
      return (
        <Text key={`underline-${key}`} style={{ textDecoration: â€˜underlineâ€™ }}>
          {children}
        </Text>
      );
    },
  },
  /**
   * Blocks receive children and depth
   * Note that children are an array of blocks with same styling,
   */
  blocks: {
    unstyled: (children, { keys }) => {
      return children.map((child, index) => {
        return (
          <View key={keys[index]}>
            <Text style={styles.text}>{child}</Text>
          </View>
        );
      });
    },
    â€˜header-oneâ€™: (children, { keys }) => {
      return children.map((child, index) => {
        return <HeadingOne key={keys[index]}>{child}</HeadingOne>;
      });
    },
    â€˜unordered-list-itemâ€™: (children, { depth, keys }) => {
      return (
        <UnorderedList key={keys[keys.length - 1]} depth={depth}>
          {children.map((child, index) => (
            <UnorderedListItem key={keys[index]}>{child}</UnorderedListItem>
          ))}
        </UnorderedList>
      );
    },
    â€˜ordered-list-itemâ€™: (children, { depth, keys }) => {
      return (
        <OrderedList key={keys.join(â€˜|â€™)} depth={depth}>
          {children.map((child, index) => (
            <OrderedListItem key={keys[index]} index={index}>
              {child}
            </OrderedListItem>
          ))}
        </OrderedList>
      );
    },
  },
  /**
   * Entities receive children and the entity data
   */
  entities: {
    // key is the entity key value from raw
    LINK: (children, data, { key }) => (
      <Link key={key} src={data.url}>
        {children}
      </Link>
    ),
  },
};
```

As you can see we return a text element for all of the `inline` styles that applies the corresponding styles to make it match the type. For each of the `block`â€™s we created our own components that have applied styles to match the formatting required. For example, here is `HeaderOne`:
```
const styles = StyleSheet.create({
  headingOne: {
    marginBottom: 4,
    color: â€˜#3a4b56â€™,
    fontWeight: 700,
    fontFamily: â€˜Public Sansâ€™,
    lineHeight: 1.35,
    fontSize: 12,
  },
});

const HeadingOne = ({ children }) => {
  return (
    <View>
      <Text style={styles.headingOne}>{children}</Text>
    </View>
  );
};
```

One of the more interesting components for lists. React PDF doesnâ€™t have a built in component for unordered or ordered lists, so we made our own. If you boil it down, a list is just a block element with nested block elements and either a number or bullet before the entry. We only support one level of nesting making this easy enough to make on our own. 

```
const styles = StyleSheet.create({
  list: {
    marginBottom: 8,
    marginLeft: 6,
  },
  listItem: {
    marginBottom: 4,
  },
  listItemText: {
    color: â€˜#6b7880â€™,
    fontFamily: â€˜IBM Plex Serifâ€™,
    fontSize: 10,
    lineHeight: 1.45,
  },
});

const UnorderedList = ({ children, depth }) => {
  return <View style={styles.list}>{children}</View>;
};

const UnorderedListItem = ({ children }) => {
  return (
    <View style={styles.listItem}>
      <Text style={styles.listItemText}>
        â€¢ &nbsp;<Text>{children}</Text>
      </Text>
    </View>
  );
};

const OrderedList = ({ children, depth }) => {
  return <View style={styles.list}>{children}</View>;
};

const OrderedListItem = ({ children, index }) => {
  return (
    <View style={styles.listItem}>
      <Text style={styles.listItemText}>
        {index + 1}. &nbsp;<Text>{children}</Text>
      </Text>
    </View>
  );
};
```

And there you have it. You have taken user input and converted it into elements that can be styled and rendered using React PDF.

One place I would like to try using Redraft is to render React Native components from HTML instead of relying on a web view.

For the full code from the example you can check out [this gist](https://gist.github.com/chadwilken/caa6d945b5d5505fe1788f53af2be244).
